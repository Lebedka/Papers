\section{The underlying dynamic logic} \label{sec:dyn_log}

It is possible construct dynamic meanings discussed in Section~\ref{sec:cont_based_dyn} in a concise and systematic way. This is achieved by defining a continuation-based dynamic logic and this section presents this logic.

Terms and types are given by Definitions~\ref{def:terms-FO} and~\ref{def:types-FO}:
\begin{definition}[$\lambda$-terms]\label{def:FO-lambda-terms}
 The set of \textbf{$\lambda$-terms} $\Lambda$ is constructed from an enumerable set of variables $V = \{ v, v_1, v_2, \dots \}$, logical constants $\land, \exists, \neg$, two special constants $::$ and $\selK$, an enumerable set of predicate symbols $R = \{ R_1, R_2, \dots  \}$ and an enumerable set of constants $K = \{ c, c_1, c_2, \dots \}$  using application and (function) abstraction:
\begin{center}
$
\begin{array}{rcl}
x \in V & \Longrightarrow & x \in \Lambda\\
c \in K & \Longrightarrow & c \in \Lambda\\
M,N \in \Lambda &  \Longrightarrow & (MN) \in \Lambda\\ 
 x \in V, M \in \Lambda&  \Longrightarrow  & (\lambda x.M) \in \Lambda \\
  M \in \Lambda&  \Longrightarrow  & (\exists M) \in \Lambda\\ 
M,N \in \Lambda &  \Longrightarrow  & (M \land N) \in \Lambda \\
M \in \Lambda &  \Longrightarrow  & (\neg M)  \in \Lambda \\
M,x \in \Lambda &  \Longrightarrow  & (M::x) \in \Lambda\\
M \in \Lambda &  \Longrightarrow  & (\selK(M))  \in \Lambda
\end{array} 
$
\end{center}
\label{def:terms-FO}
\end{definition}

%M,x \in \Lambda &  \Longrightarrow  & (\updtfo(M,x))  \in \Lambda\\
%M \in \Lambda &  \Longrightarrow  & (\selK(M))  \in \Lambda\\


\begin{definition}[Free variables] The set of \textbf{free variables} of $t$, $FV(t)$, is defined inductively as follows:
\begin{align*}
FV(x) = \ &  \{ x \} \\
FV(c) = \ & \{ \} \\
%FV(\exists M) =  \ & FV(M) \\
%FV(M \land N) = \ & FV(M) \cup FV(N)  \\
%FV(\neg M) =  \ & FV(M) \\
%FV( \updtfo (M,x)) = \ &  FV(M) \cup FV(x)  \\
%FV(\selK(M)) = \ & FV(M) \\
FV(M N) = \ & FV(M) \cup FV(N)  \\
FV( \lambda x. M) = \ & FV(M) - \{ x \}
\end{align*}
\end{definition}

\begin{definition}[Types]
The set $\Types$ of types is defined inductively as follows:
\begin{center} $
\begin{array}{rll}
\text{Atomic types:} & \iota \in \Types & \text{(static individuals)} \\
 & o \in \Types &  \text{(static propositions)} \\
&  \gamma \in \Types &  \text{(context)} \\\\
 \text{Complex types:} & \alpha, \beta \in \Types \Longrightarrow & (\alpha \rightarrow \beta) \in \Types \\
\end{array} 
$ \end{center}
\label{def:types-FO}
\end{definition}

Typing rules define typing relations between terms and types:
\begin{definition}[Typing rules] A statement $t:\delta$, meaning $t$ has type $\delta$, is \textbf{derivable} from the basis $\Delta$, i.e. $\Delta \vdash t: \delta$, if $\Delta \vdash t: \delta$ can be produced using the following rules:

\begin{prooftree}
\AXC{} \RightLabel{axiom}
\UIC{$\Gamma, x: \alpha \vdash x: \alpha $}
\end{prooftree}

\begin{prooftree}
\AXC{} \RightLabel{axiom}
\UIC{$\Gamma \vdash \top: o $}
\end{prooftree}

\begin{prooftree}
\AXC{} %\RightLabel{axiom}
\UIC{$\Gamma, M: o, N:o \vdash M \land N: o $}
\end{prooftree}

\begin{prooftree}
\AXC{} %\RightLabel{axiom}
\UIC{$\Gamma, M: \iota \rightarrow o \vdash \exists M: o $}
\end{prooftree}

\begin{prooftree}
\AXC{} %\RightLabel{axiom}
\UIC{$\Gamma, M: o \vdash \neg M: o $}
\end{prooftree}

\begin{prooftree}
\AXC{} %\RightLabel{axiom}
\UIC{$\Gamma, c: \gamma \vdash \selK \ c:  \iota $}
\end{prooftree}

\begin{prooftree}
\AXC{} %\RightLabel{axiom}
\UIC{$\Gamma, i: \iota, c: \gamma \vdash (i::c) :  \gamma$}
\end{prooftree}


\begin{prooftree}
\AXC{} \RightLabel{axiom}
\UIC{$\Gamma \vdash c_{iv}:   \iota \rightarrow o $}
\end{prooftree}


\begin{prooftree}
\AXC{} \RightLabel{axiom}
\UIC{$\Gamma \vdash c_{tv}:   \iota \rightarrow \iota \rightarrow o $}
\end{prooftree}

\begin{prooftree}
\AXC{} \RightLabel{axiom}
\UIC{$\Gamma \vdash c_{n}:   \iota \rightarrow o $}
\end{prooftree}

\begin{prooftree}
\AXC{} \RightLabel{axiom}
\UIC{$\Gamma \vdash c_{np}:   (\iota \rightarrow o) \rightarrow o $}
\end{prooftree}

%\begin{prooftree}
%\AXC{} \RightLabel{axiom}
%\UIC{$\Gamma \vdash c_{det}:   (\iota \rightarrow o) \rightarrow ( ( \iota \rightarrow o ) \rightarrow o  )$}
%\end{prooftree}

\begin{prooftree}
\AXC{} \RightLabel{axiom}
\UIC{$\Gamma \vdash c_{rp}:  (  ((\iota \rightarrow o) \rightarrow o)  \rightarrow o)  \rightarrow   ( \iota \rightarrow o ) \rightarrow ( \iota \rightarrow o )$}
\end{prooftree}


\begin{prooftree}
\AXC{$\Gamma \vdash v: \alpha \rightarrow \beta$}
\AXC{$\Gamma \vdash u: \alpha$} \RightLabel{app}
\BIC{$\Gamma \vdash vu: \beta$}
\end{prooftree}

\begin{prooftree}
\AXC{$\Gamma, x: \alpha \vdash v:\beta$} \RightLabel{abs}
\UIC{$\Gamma \vdash \lambda x.v: \alpha \rightarrow \beta$}
\end{prooftree}
where $c_{tv}$,  $c_{iv}$, $c_{n}$, $c_{np}$ and $c_{rp}$ are constants standing for transitive and intransitive  verbs, nouns, noun phrases and relative pronouns respectively. Typing rules for other syntactic categories can be added analogously.

\end{definition}

The first axiom and the two rules (application and abstraction) are standard typing relations in simply-typed lambda calculus. The second axiom determines the type of the logical $\top$ symbol. The constant $\selK$ has type $(\gamma \rightarrow \iota)$ and the constant $::$ has type $(\iota \rightarrow \gamma \rightarrow \gamma)$. 

For each logical constant ($\neg$, $\land$ and $\exists$), its dynamic counterpart is specified by the following definition: 
\begin{definition}[Dynamic logical constants] \label{def:DLCnst-FO} Let $\A2$ and $\B2$ be terms of type $(\gamma \rightarrow (\gamma \rightarrow o) \rightarrow o)$, $\P2$ be the term of type $(\iota \rightarrow \gamma \rightarrow (\gamma \rightarrow o) \rightarrow o)$, $e$ and  $e'$ be terms of type $\gamma$, $\phi$ be a term of type $(\gamma \rightarrow o)$, $\x1$ be the term of type $\iota$. \textbf{Dynamic negation, conjunction and existential quantification} are defined respectively as follows:
\begin{subequations}
\begin{align}
\n2 \A2 \defeq \ & \lambda e \phi. \neg (\A2 e (\lambda e'. \top) ) \land \phi e  \label{def:DLCnst-FO-neg} \\
\A2 \cnj2 \B2 \defeq \ & \lambda e\phi. \A2 e (\lambda e'. \B2 e' \phi) \label{def:DLCnst-FO-cnj} \\
\ex2 ( \lambda \x1. \P2[\x1]) \defeq \ & \lambda e \phi. \exists ( \lambda \x1. \P2 [\x1] \ (x::e) \ \phi )\label{def:DLCnst-FO-ex} 
\end{align}
\end{subequations}
\end{definition}
Dynamic negation of a dynamic proposition $\A2$, $\n2 \A2$, is an abbreviation used for the term shown in~\eqref{def:DLCnst-FO-neg}. Within the body of this term, the continuation and context of $\A2$ are ``erased'' (by giving the term $(\lambda e'. \top)$ as the second argument of $\x2$)\footnote{This can be more clearly seen from Corollary~\ref{cor:DL-FO-handtop}.}, the resulting static proposition is negated, and the conjunct $\phi e$ is added. Note that both $\phi$ and $e$ are variables bound by $\lambda$. Therefore, the context of $\A2$ is not available to the continuation of the resulting term $\n2 \A2$. 

Dynamic existentially quantified term $\ex2 ( \lambda \x1. \P2[\x1]) $ is an abbreviation for the term shown in~\eqref{def:DLCnst-FO-ex}. It has a $\lambda$-abstraction over variables $e$ and $\phi$ and an existentially quantified variable $\x1$. Its body contains $\P2[\x1]$, which is given $e$ updated with $\x1$, $(x::e)$, and $\phi$ as arguments.  Note that $\n2$ and $\ex2$ are defined respectively via $\neg$ and $\exists$.
Dynamic conjunction is defined as a composition of two dynamic terms. The logical conjunction of static propositions is provided by the fact that each dynamic proposition has a conjunct $\phi e $ in its body.

\comments{
 Static negation, conjunction and existential quantification can now be translated into dynamic ones: \todoK{I think this definition is not really necessary.}
\begin{definition}[Dynamization of terms]\label{def:DTerms-FO} Let $\P1$ be a term of type $(\iota_1 \rightarrow \dots \rightarrow \iota_n \rightarrow o)$, $\x1$ and $\B1$ be terms of type $o$, $\t1_1, \dots, \t1_n$ and $\x1$ be terms of type $\iota$. Then propositions, negated propositions, conjunctions of two propositions and existentially quantified propositions are dynamized in the following way:
\begin{subequations}
\begin{align}
%\tr{ \P1 \t1_1 \dots \t1_n } \defeq \ & \lambda e \phi . \P1 \t1_1 \dots \t1_n \land \phi e  \label{def:DTerms-FO-P}\\
%\tr{ \neg \x1  } \defeq \ & \n2 \tr{\x1}  \label{def:DTerms-FO-neg}\\
%\tr{ \x1 \land \B1} \defeq \ & \tr{\x1} \cnj2 \tr{\B1}  \label{def:DTerms-FO-cnj}\\
%\tr{\exists( \lambda \x1. \P1 [\x1])} \defeq \ & \ex2( \lambda  \x1. \tr{\P1 [\x1]})  \label{def:DTerms-FO-ex}
\tr{ \neg   } \defeq \ & \n2  \label{def:DTerms-FO-neg}\\
\tr{ \land } \defeq \ &  \cnj2   \label{def:DTerms-FO-cnj}\\
\tr{\exists( \lambda \x1. \P1 [\x1])} \defeq \ & \ex2( \lambda  \x1. \tr{\P1 [\x1]})  \label{def:DTerms-FO-ex}
\end{align}
\end{subequations}
\end{definition}
%Equation~\eqref{def:DTerms-FO-P} defines the dynamization of a proposition $\P1 \t1_1 \dots \t1_n $ of type $o$ by adding a $\lambda$-abstraction with two arguments  $e$ and $\phi$  (of types $\gamma$ and $(\gamma \rightarrow o)$ respectively) and a conjunct $\phi e$. Therefore, the resulting dynamic term is of type $(\gamma \rightarrow (\gamma \rightarrow o) \rightarrow o )$, the type of a dynamic proposition. Equations~\ref{def:DTerms-FO-neg},~\ref{def:DTerms-FO-cnj} and~\ref{def:DTerms-FO-ex} extend dynamization to non-atomic formulas.
}


Each static type can be dynamized in the following way:
\begin{definition}[Dynamization of types]\label{def:DTypes-FO} Let $\iota$ and $o$ be atomic types, $\gamma$ be a type parameter, $\alpha$ and $\beta$ be arbitrary types. Then the types are \textbf{dynamized} in the following way:
\begin{subequations}
\begin{align}
\tr{\iota} \defeq \ &  \iota  \label{def:DTypes-FO:iota}\\
 \tr{o} \defeq \ & \gamma \rightarrow (\gamma \rightarrow o) \rightarrow o \label{def:DTypes-FO:o}\\
  \tr{\alpha \rightarrow \beta} \defeq \ & \tr{\alpha}  \rightarrow \tr{\beta} \label{def:DTypes-FO:atob}
\end{align}
\end{subequations}
\end{definition}
Note that the type $o$ of a static proposition is transformed to type $(\gamma \rightarrow (\gamma \rightarrow o) \rightarrow o)$. Type $(\gamma \rightarrow (\gamma \rightarrow o) \rightarrow o)$ is thus the type of a dynamic proposition. Therefore, dynamic propositions are functions from $\gamma$ (type of context) and $(\gamma \rightarrow o)$ (type of continuation) to $o$ (type of static proposition).
Static and dynamic individuals are defined to have the same type.

Definition~\ref{def:DTerms} formalizes a systematic translation of every term $\t1$ to its dynamic equivalent $\tr{\t1}$. The translation is relatively straightforward for all kinds of terms except non-logical constants. Non-logical constants have various types, therefore their dynamization should be defined in a special way. This is accomplished with the dynamic embedding $\dyn{\delta}{}$ and static projection $\stat{\delta}{}$ functions defined in~\ref{def:DnmStd}. The dynamic embedding function transforms static terms into equivalent dynamic terms. The static projection function is a function that transforms dynamic terms (obtained via $\dyn{\delta}{}$) into original static terms. Note that the dynamic embedding function and the static projection functions are mutually dependent.


\begin{definition}[Dynamic embedding and static projection functions]\label{def:DnmStd}
\textbf{Dynamic embedding function} is a function $\dyn{\delta}{}$ that has type  $( \delta \rightarrow \tr{\delta})$ and is inductively defined on the type $\delta$ as follows:
\begin{subequations}
\begin{align}
\dnm{\iota}{\x1} \ \defeq \ & \x2 \label{def:D_iota}\\
\dnm{o}{\P1}  \ \defeq \ & \lambda e \phi. \P1 \land \phi e \label{def:D_o}\\
\dnm{\alpha \rightarrow \beta}{\h1} \ \defeq \ &  \lambda \x2. \dnm{\beta}{ \h1 \ \std{\alpha}{\x2}} \label{def:D_atob}
\end{align}
\end{subequations}

\textbf{Static projection function} is a function $\stat{\delta}{}$ that has type $(\tr{\delta} \rightarrow  \delta)$ and is inductively defined on the type $\delta$ as follows:
\begin{subequations}
\begin{align}
\std{\iota}{ \x2}\ \defeq \ & \x1 \label{def:S_iota}\\
\std{o}{\P2} \ \defeq \ & \P2 e (\lambda e. \top) \label{def:S_o}\\
\std{\alpha \rightarrow \beta}{\h2} \  \defeq \ & \lambda \x1. \std{\beta}{\h2 \ \dnm{\alpha}{\x1}}  \label{def:S_atob}
\end{align}
\end{subequations}
\end{definition}


Equation~\eqref{def:D_iota} says that if $\x1$ is a term of type $\iota$, then the result of its dynamic embedding is a itself. According to Equation~\eqref{def:D_o}, dynamic embedding of a term $\P1$ of type $ o$ leads to a dynamic proposition. Equation~\eqref{def:D_atob} specifies dynamic embedding of a term $\h1$ of the complex type $(\alpha \rightarrow \beta)$. The resulting term has to be of type $(\tr{\alpha} \rightarrow \tr{\beta})$. It is defined by abstracting over a variable of type $\tr{\alpha}$ and specifying the body of type $\tr{\beta}$. The body has to be obtained by dynamic embedding of a term of which $\h1$ is a subterm. Since the body of the argument of the function $\dyn{\beta}{}$ has to be the term of type $\beta$, $\h1$ is given the static version $\std{\alpha}{\x2}$ of $\x2$ as the argument. 


The static projection function is the inverse of the dynamic embedding function. Equation~\eqref{def:S_iota} says that if $\x2$ is a dynamic term of type $ \iota$, then the static projection function returns the same term. Equation~\eqref{def:S_o} shows that a dynamic proposition is provided the context and an empty continuation to become a static proposition. Finally, Equation~\eqref{def:S_atob} defines the translation of a dynamic term $\h2$ of a complex type $(\tr{\alpha} \rightarrow \tr{\beta})$ to its static equivalent of type $(\alpha \rightarrow \beta)$. First, there is an abstraction over a variable of type $\alpha$, then the body of type $\beta$ is obtained by applying $\stat{\beta}{}$ to a term of which $\h2$ is a subterm. Therefore, to return a term of type $\tr{\beta}$, $\h2$ has to be provided a term of type $\tr{\alpha}$ as an argument. This term is obtained by applying dynamic embedding function $\dnm{\alpha}{x}$ to $ \x1$.


Now, we can define the modular dynamization of any static term:
\begin{definition}[Dynamization of $\lambda$-terms] A term $\t1$ of type $\delta$ is \textbf{dynamized} into a term $\tr{\t1}$ of type $\tr{\delta}$ in the following way:
\begin{subequations}
\begin{itemize}

\item If $\t1$ is a non-logical constant $\k1$, then
\begin{align}
 \tr{\k1} \defeq \dnm{\delta}{\k1} \label{def:DTerms:cnst}
 \end{align}
 
 \item If $t$ is a variable $\x1$, then
\begin{align}
\tr{\x1} \defeq \x2 \label{def:DTerms:var}
\end{align}

 
 \item If $\t1$ is an application $vu$, then 
\begin{align} 
\tr{vu}   \defeq  \tr{v} \ \tr{u} \label{def:DTerms:app}
\end{align}

\item If $\t1$ is an abstraction $\lambda \x1. \v1$, then
\begin{align}
 \tr{\lambda \x1. \v1} \defeq \lambda \x2. \tr{\v1} \label{def:DTerms:abs}
 \end{align}
 
 \item If $\t1$ is of the form $v \land u$, then
\begin{align} 
 \tr{v \land u} \defeq \tr{v} \cnj2 \tr{u}  \label{def:DTerms:cnj}
\end{align} 
  
\item If $\t1$ is of the form $\ex1 (\lambda x. v[x])$, then
\begin{align}
 \tr{\ex1 (\lambda x. v[x])} \defeq \ex2 (\tr{\lambda \x1. v[\x1]}) \label{def:DTerms:exist}
 \end{align} 

\item If $\t1$ is of the form $\n1 \tr{v}$, then
\begin{align}
 \tr{\n1 v} \defeq  \n2 v  \label{def:DTerms:neg}
\end{align}
 
 \end{itemize}
 \end{subequations}

 
\label{def:DTerms}
\end{definition}

A non-logical constant $\k1$ is dynamized by applying function $\dyn{}{}$ to it. Dynamization of a variable is the same variable. Dynamization of an application is the application of each of the terms dynamized separately. Dynamization of an abstraction is the dynamization of the body of it, abstracted over the same variable. Dynamic conjunction is a dynamic composition of two terms. Dynamization of a term bound by an existential quantifier is defined as a term in which $\ex2$ is applied to the dynamized term. Dynamization of a negated term is defined as dynamic negation $\n2$ applied to the dynamized term.

 Rules defined in~\ref{def:DTerms} allow the presentation of dynamic terms in a compact way. They ensure that dynamic terms are structurally analogous to their static counterparts and, therefore, are more intuitive.


%Note that Definitions~\ref{def:DLCnst-FO} and~\ref{def:DTerms-FO} allow representing de~Groote's~\cite{deGroote:2006:Towards-a-Montagovian-Account-of-Dynamics} dynamic terms in a compact way.  While interpretations in~\cite{deGroote:2006:Towards-a-Montagovian-Account-of-Dynamics} explicitly show extra parameters, i.e. contexts and continuations, these new definitions make it possible to hide these parameters. Moreover, the resulting compact dynamic terms are structurally analogous to their original static counterparts and, hence, are more intuitive.


\begin{remark} In equations below, terms on the left side of $\defeq$ abbreviate respective terms on the right side:
\begin{subequations}
\begin{align*} 
\A2 \impK2 \B2 \defeq \ & \n2 (\A2 \cnj2 \n2 \B2) \\
\all2( \lambda \x1. \P2[\x1]) \defeq \ & \n2 \ex2 ( \lambda \x1. \n2 \P2 [\x1] )
\end{align*} 
\end{subequations}
\label{remark:impforall}
\end{remark}



\todoK{Now, with the definitions above, this proposition has to be proven in a complex way (as was done in the thesis)...  Actually, I am a bit confused which exactly definitions we want to use in this paper...}
Proposition~\ref{thrm:scopeextension-G}  proves a useful $\beta$-equivalence that can be useful when computing interpretations of certain phrases containing an existentially quantified variable.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proposition} For all terms $\A1$ and $\B1$ of type $o$ such that  $\x1 \in FV(\A1)$ and $\x1 \notin FV(\B1)$ for an $\x1$ of type~$\iota$, the following equivalence holds: \label{thrm:scopeextension-G}
\begin{align*}
  {\ex2} (\lambda \x1.  \tr{\A1[\x1]}) \cnj2 \tr{\B1}  =_{\beta}  \ex2 (\lambda \x1.  \tr{\A1[\x1]}  \cnj2  \tr{\B1} ) 
\end{align*} 
\end{proposition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{proof} Since $\A1[\x1]$ and $\B1$ are terms of type $o$, their dynamic equivalents are term of type $(\gamma \rightarrow (\gamma \rightarrow o) \rightarrow o)$ and have the following forms:
\begin{subequations}
\begin{align}
 \tr{\A1[\x1]}  & = \lambda e \phi. \A1'[x] \land \phi e) \label{eq:Adynamic} \\
 \tr{\B1} & = \B1' \land  \phi e \label{eq:Bdynamic} 
\end{align}
\end{subequations}

%
\begin{align}
 &  {\ex2} (\lambda \x1.  \tr{\A1[\x1]}) \cnj2 \tr{\B1}  \notag \\ 
 \bred \  &  ( \lambda e \phi.  \exists ( \lambda \x1. \A1'[x] \land \phi (x::e) ) )  \cnj2  \tr{\B1}  \tag{by~\eqref{def:DLCnst-FO-ex} and~\eqref{eq:Adynamic}}\\
= \ &  \lambda e \phi. ( \lambda e \phi.  \exists ( \lambda \x1. \A1'[x] \land \phi (x::e) ) ) e ( \lambda e. \tr{\B1} e \phi  ) \tag{by~\eqref{def:DLCnst-FO-cnj}} \\
\bred \ &   \lambda e \phi. ( \lambda e \phi.  \exists ( \lambda \x1. \A1'[x] \land \phi (x::e) ) ) e ( \lambda e. \B1' \land  \phi e  )  \tag{by~\eqref{eq:Bdynamic}}\\
\bred \ &   \lambda e \phi.  \exists ( \lambda \x1. \A1'[x] \land  (  \B1' \land  \phi  (x::e)  ) ) \label{eq:DLGexscope1}
\end{align}
%
\begin{align}
 &  \ex2 (\lambda \x1.  \tr{\A1[\x1]}  \cnj2  \tr{\B1} ) \notag \\
  = \ &    \ex2 (\lambda \x1.  \lambda e \phi. \tr{\A1[\x1]}  e (\lambda e. \tr{\B1}  e \phi)  ) \tag{by~\eqref{def:DLCnst-FO-cnj}} \\
  \bred \ &  \ex2 (\lambda \x1.  \lambda e \phi. (\lambda e \phi. \A1'[x] \land \phi e ) e (\lambda e. \B1' \land  \phi e)  ) \tag{by~\eqref{eq:Bdynamic}}\\
    \bred \ &   \ex2 (\lambda \x1.  \lambda e \phi.\A1'[x] \land  (\B1' \land  \phi e )   ) \notag \\
\bred \ &   \lambda e \phi.  \exists ( \lambda \x1.   \A1'[x] \land  (  \B1' \land  \phi ( \x1:: e ) ) ) \tag{by~\eqref{def:DLCnst-FO-ex}}
\end{align}
%
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proposition} For all $\h1$ and $\v1$ of type $o$, and for all $\u1$ of type $\gamma$, the following holds: $$\tr{\h1} \u1 (\lambda e.\v1) =  \h1 \land \v1$$ where $e$ is a variable of type $\gamma$. \label{DL-FO-handv}
\end{proposition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof}
The proof is by induction on the structure of the term $\h1$.
\begin{itemize}
\item $\h1$ is a proposition of the form $\P1 t_1 \dots t_n$.
\begin{align}
\tr{\P1 \t1_1 \dots \t1_n} \u1  (\lambda e.\v1)  = \ & (\lambda e \phi. \P1 \t1_1 \dots \t1_n \land \phi e) \u1  (\lambda e.\v1) \tag{by~\eqref{def:DTerms-FO-P}} \\
\bconv \ & (\lambda  \phi. \P1 \t1_1 \dots \t1_n \land \phi \u1)   (\lambda e.\v1) \notag \\
\bconv \ & \lambda  \phi. \P1 \t1_1 \dots \t1_n \land (\lambda e.\v1) \u1    \notag \\
\bconv \ & \lambda  \phi. \P1 \t1_1 \dots \t1_n \land \v1    \notag 
\end{align}

\item  $\h1$ is a negated proposition $ \neg \w1$. 
\begin{align}
\tr{\neg \w1} \u1 (\lambda e. \v1) = \ &  \n2 \tr{\w1}  \u1 (\lambda e. \v1)  \tag{by~\eqref{def:DTerms-FO-neg}} \\
= \ & ( \lambda e \phi. \neg (\tr{\w1} e (\lambda e'. \top) ) \land \phi e)  \u1 (\lambda e. \v1)  \tag{by~\eqref{def:DLCnst-FO-neg}} \\
\bconv \ & ( \lambda \phi.\neg (\tr{\w1} \u1 (\lambda e'. \top) ) \land \phi \u1 ) (\lambda e. \v1)  \notag \\
\bconv \ & \neg (\tr{\w1} \u1 (\lambda e'. \top) ) \land  (\lambda e. \v1) \u1   \notag \\
\bconv \ & \neg (\tr{\w1} \u1 (\lambda e'. \top) ) \land   \v1   \notag \\
= \ & \neg(\w1 \land \top) \land \v1 \tag{by I.H.} \\
= \ & \neg \w1 \land \v1
\end{align}

\item $\h1$ is a conjunction of two propositions $\w1 \land \z1$.
\begin{align}
(\tr{\w1 \land \z1}) \u1 (\lambda e. \v1)  = \ & (\tr{\w1} \cnj2 \tr{\z1}) \u1 (\lambda e. \v1)   \tag{by~\eqref{def:DTerms-FO-cnj}} \\
 = \ & (\lambda e\phi. \tr{\w1} e (\lambda e'. \tr{\z1} e' \phi) ) \u1 (\lambda e. \v1)   \tag{by~\eqref{def:DLCnst-FO-cnj}} \\
\bconv \ & (\lambda \phi. \tr{\w1} \u1 (\lambda e'. \tr{\z1} e' \phi) ) (\lambda e. \v1)   \notag \\
\bconv \ &  \tr{\w1} \u1 (\lambda e'. \tr{\z1} e'  (\lambda e. \v1) )  \notag \\
= \ &  \tr{\w1} \u1 (\lambda e'. \z1 \land \v1)  \tag{by I.H., $e \notin FV(\v1)$} \\
= \ &  \w1 \land (\z1 \land \v1)  \tag{by I.H., $e' \notin FV(\z1 \land \v1)$} \\
\logeq \ & (\w1 \land \z1) \land \v1 \notag
\end{align}

\item $\h1$ is an existentially quantified formula of the form $\exists( \lambda \x1. \P1 [\x1])$.
\begin{align}
\tr{\exists ( \lambda \x1. \P1 [\x1])} \u1 (\lambda e. \v1)  = \ & ( \ex2 ( \lambda \x1. \tr{\P1 [\x1]})  ) \u1 (\lambda e. \v1)   \tag{by~\eqref{def:DTerms-FO-ex}} \\
 = \ & ( \lambda e \phi. \exists ( \lambda \x1. \P2 [\x1] (x::e) \phi  )) \u1 (\lambda e. \v1)   \tag{by~\eqref{def:DLCnst-FO-ex}} \\
\bconv \ & ( \lambda  \phi. \exists ( \lambda \x1. \P2 [\x1] (x::\u1) \phi  ))  (\lambda e. \v1)  \notag \\
\bconv \ & \exists ( \lambda \x1. \P2 [\x1] (x::\u1) (\lambda e. \v1)  )  \notag \\
= \ & \exists ( \lambda \x1. \P1 [\x1] \land \v1  )  \tag{by I.H.} \\
= \ & \exists ( \lambda \x1. \P1 [\x1]) \land \v1    \tag{$\x1 \notin FV(\v1)$} 
\end{align}

\end{itemize}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{corollary} \label{cor:DL-FO-handtop} For all propositions $\t1$ of type $o$, and for all terms $\u1$ of type $\gamma$, the following folds: 
\begin{align}\tr{\t1} \u1 (\lambda e. \top) \logeq  \t1 \notag  %\label{eq:DL-FO-handtop}
\end{align}
where $e$ is a variable of type $\gamma$.
 \label{DL-FO-handtop}
\end{corollary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{proof} Take $\v1$ equal to $\top$ in Proposition~\ref{DL-FO-handv}. Then
$$\tr{\t1} \u1 (\lambda e. \top) = \t1 \land \top \logeq \t1$$
\end{proof}


\begin{definition} A dynamic proposition $\t2$ is true in a model $\mathcal{M}$, denoted
$\mathcal{M}~\models_{dyn}~\t2$, if and only if $\mathcal{M}$ $\models$ $\t2 u (\lambda e. \top)$ for every $u$ of type $\gamma$. \label{def:dyntrueinmodel}
\end{definition}

\begin{theorem}[Conservation] A proposition $\t1$ is true in a model $\mathcal{M}$  if and only if its dynamic variant $\tr{\t1}$ is true in the same model: 
 $$\mathcal{M} \models \t1 \ \text{iff} \ \mathcal{M} \models_{dyn} \tr{\t1}$$
 \label{th:conservation:FO}
\end{theorem}
\begin{proof}

If $\mathcal{M} \models \t1$, then, by Corollary~\ref{cor:DL-FO-handtop}, $\mathcal{M} \models \tr{\t1} \u1 (\lambda e.\top)$. Therefore, by Definition~\ref{def:dyntrueinmodel}, $\mathcal{M} \models_{dyn} \tr{\t1}$.

If $\mathcal{M} \models_{dyn} \tr{\t1}$, then, by Definition~\ref{def:dyntrueinmodel}, $\mathcal{M} \models \tr{\t1} \u1 (\lambda e.\top)$. Therefore, by Corollary~\ref{cor:DL-FO-handtop}, $\mathcal{M} \models \t1$.
\end{proof}

The conservation theorem proves that a static proposition and its dynamic version defined in this section hold in the same models.


